# 设计模式


#### 面向对象
面向对象通过**封装**、**继承**、**多态**把程序的耦合度降低，它的好处，以活字印刷为例
* **可维护**。要改，只需更改要改之字
* **可复用**。这些字并非用完这次就无用，完全可以在后来的印刷中重复使用
* **可扩展**。若要加字，只需另刻字加入即可
* **灵活性好**。字的排列其实可能是竖排可能是横排，此时只需将活字移动就可做到满足排列需求

#### 单一职责原则[SRP]
* 就一个类而言，应该仅有一个引起它变化的原因
* 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个职责
* 如果一个类继承的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

#### 开放-封闭原则[OCP][The Open-Closeed Principle]
* 是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改
* 对于扩展是开放的，对于更改是封闭的
* 面对需求，对程序的改动（这里的改动理解为是为了新增需求，而不是修改原有需求而改动代码，会更有助于理解这句话）是通过增加新代码进行的，而不是更改现有的代码
* 绝对的对修改关闭是不可能的。在我们最初编写代码时，假设变化不会发生，当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
* 对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意，拒绝不成熟的抽象和抽象本身一样重要

#### 依赖倒转原则
* 高层模块不应该依赖底层模块。两个都应该依赖抽象。（举例，CPU是高层模块，主板是底层模块，CPU不应该依赖具体的主板，而只需要依赖定义好的接口规范即可）
* 针对接口编程，不要对实现编程
* 为什么是倒转？面向过程的开发时，一般都会是高层模块依赖底层模块（比如项目代码直接调用具体的数据库代码，而不是仅依赖通用的数据库接口），而面向对象是不管高层模块还是底层模块，都依赖于抽象

#### 里氏代换原则[LSP]
* 子类型必须能够替换掉它们的父类型
* 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能能够在父类的基础上增加新的行为
* 正由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。（这也是实现开放-封闭原则和依赖倒转原则的基础）

#### 迪米特法则[LoD]
* 也叫最少知识（Least Knowledge）原则，告诉我们要减少对象之间的交互，强调类之间的松耦合。不要让太多的类耦合在一起，免得修改系统中的一部分会影响到其他部分。
* 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。